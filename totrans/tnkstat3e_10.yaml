- en: Estimation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://allendowney.github.io/ThinkStats/chap08.html](https://allendowney.github.io/ThinkStats/chap08.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Suppose you live in a town with a population of 10,000 people, and you want
    to predict who will win an upcoming election. In theory, you could ask everyone
    in town who they plan to vote for, and if they all answered honestly, you could
    make a reliable prediction.
  prefs: []
  type: TYPE_NORMAL
- en: But even in a small town, it is probably not practical to survey the entire
    population. Fortunately, is it not necessary. If you survey a random subset of
    the people, you can use the sample to infer the voting preferences of the population.
    This process – using a sample to make inferences about a population – is called
    statistical inference.
  prefs: []
  type: TYPE_NORMAL
- en: Statistical inference includes estimation, which is the topic of this chapter,
    and hypothesis testing, which is the topic of the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to run this notebook on Colab](https://colab.research.google.com/github/AllenDowney/ThinkStats/blob/v3/nb/chap08.ipynb).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]  ## Weighing Penguins'
  prefs: []
  type: TYPE_NORMAL
- en: Suppose you are a researcher in Antarctica, studying local populations of penguins.
    One of your tasks is to monitor the average weight of the penguins as it varies
    over the course of the year. It would be impractical to weigh every penguin in
    the environment, so your plan is to collect a random sample of 10 penguins each
    week, weigh them, and use the sample to estimate the mean of the entire population
    – which is called the **population mean**.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many ways you could use the sample to estimate the population mean,
    but we’ll consider just two: the sample mean and the sample median. They are both
    reasonable choices, but let’s see which is better – and think about what we mean
    by “better”.'
  prefs: []
  type: TYPE_NORMAL
- en: For purposes of demonstration, we’ll assume that penguin weights are drawn from
    a normal distribution with known mean and standard deviation, which I’ll denote
    `mu` and `sigma` and assign values in kilograms.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: These values are the **parameters** of the normal distribution, which means
    that they specify a particular distribution. Given these parameters, we can use
    NumPy to simulate the sampling process and generate a sample of any size. For
    example, here’s a hypothetical sample of 10 weights.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: And here are the mean and median of the sample.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The mean and median are different enough that we should wonder which is a better
    estimate. To find out, we’ll use the following function to generate hypothetical
    samples with the given size, `n`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As a first experiment, let’s see how the sample mean and sample median behave
    as the sample size increases. We’ll use the NumPy function `logspace` to make
    a range of `ns` from 10 to 100,000, equally spaced on a logarithmic scale.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use a list comprehension to generate a hypothetical sample for each
    value of `n`, compute the mean, and collect the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: And we’ll do the same for the median.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: A statistic, like the sample mean or median, that’s used to estimate a property
    of a population is called an **estimator**.
  prefs: []
  type: TYPE_NORMAL
- en: The following figure shows how these estimators behave as we increase the sample
    size. The horizontal line shows the actual mean in the population.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '![_images/8a89df65f38fa8c3eaa4ec9bf174f6ee3ac0648298efe16ea79baa534de24d46.png](../Images/3626ef39a880aebdb5029d366b757eca.png)'
  prefs: []
  type: TYPE_IMG
- en: For both estimators, the estimates converge to the actual value as the sample
    size increases. This demonstrates that they are **consistent**, which is one of
    the properties a good estimator should have. Based on this property, the mean
    and median seem equally good.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous figure, you might notice that the estimates are sometimes too
    high and sometimes too low – and it looks like the variation is roughly symmetric
    around the true value. That suggests another experiment: if we collect many samples
    with the same size and compute many estimates, what is the average of the estimates?'
  prefs: []
  type: TYPE_NORMAL
- en: The following loop simulates this scenario by generating 10,001 samples of 10
    penguins and computing the mean of each sample.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The average of the means is close to the actual mean we used to generate the
    samples: 3.7 kg.'
  prefs: []
  type: TYPE_NORMAL
- en: The following loop simulates the same scenario, but this time it computes the
    median of each sample.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The average of these hypothetical medians is also very close to the actual population
    mean.
  prefs: []
  type: TYPE_NORMAL
- en: These results demonstrate that the sample mean and median are **unbiased** estimators,
    which means that they are correct on average. The word “bias” means different
    things in different contexts, which can be a source of confusion. In this context,
    “unbiased” means that the average of the estimates is the actual value.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we’ve shown that both estimators are consistent and unbiased, but it’s
    still not clear which is better. Let’s try one more experiment: let’s see which
    estimator is more accurate. The word “accurate” also means different things in
    different contexts – as one way to quantify it, let’s consider the **mean squared
    error** (MSE). The following function computes the differences between the estimates
    and the actual value, and returns the mean of the squares of these errors.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we can only compute MSE if we know the actual value. In practice,
    we usually don’t – after all, if we knew the actual value, we wouldn’t have to
    estimate it. But in our experiment, we know that the actual population mean is
    3.7 kg, so we can use it to compute the MSE of the sample means.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: If we have samples with size 10 and we use the sample mean to estimate the population
    mean, the average squared error is about 0.021 kilograms squared. Now here’s the
    MSE of the sample medians.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: If we use the sample medians to estimate the population mean, the average squared
    error is about 0.029 kilograms squared. In this example, the sample mean is better
    than the sample median; and in general, if the data are drawn from a normal distribution,
    it is the *best* unbiased estimator of the population mean, in the sense that
    it minimizes MSE.
  prefs: []
  type: TYPE_NORMAL
- en: Minimizing MSE is a good property for an estimator to have, but MSE is not always
    the best way to summarize errors. For one thing, it is hard to interpret. In this
    example, the units of MSE are kilograms squared, so it’s hard to say what that
    means.
  prefs: []
  type: TYPE_NORMAL
- en: One solution is to use the square root of MSE, called “root mean squared error”,
    or RMSE. Another option is to use the average of the absolute values of the errors,
    called the “mean absolute error” or MAE. The following function computes MAE for
    a sequence of estimates.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here’s the MAE of the sample means.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: And the sample medians.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: On average, we expect the sample mean to be off by about 0.115 kg, and the sample
    median to be off by 0.137 kg. So the sample mean is probably the better choice,
    at least for this example.
  prefs: []
  type: TYPE_NORMAL
- en: Robustness
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now let’s consider a different scenario. Suppose that 2% of the time, when you
    try to weigh a penguin, it accidentally presses the units button on the scale
    and the weight gets recorded in pounds instead of kilograms. Assuming that the
    error goes unnoticed, it introduces an outlier in the sample.
  prefs: []
  type: TYPE_NORMAL
- en: The following function simulates this scenario, multiplying 2% of the weights
    by the conversion factor 2.2 pounds per kilogram.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: To see what effect this has on the distribution, we’ll generate a large sample.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: To plot the distribution of the sample, we’ll use KDE and the `Pdf` object from
    [Chapter 6](chap06.html#section-kernel-density-estimation).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '![_images/eec8f313b7382e51850036931f3410bbc3b63968fefbb269026643e735035396.png](../Images/abbbb0010c3d98dac0dcf23e5ee2b059.png)'
  prefs: []
  type: TYPE_IMG
- en: In addition to the mode near 3.7 kg, the measurement errors introduce a second
    mode near 8 kilograms.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s repeat the previous experiment, simulating many samples with size
    10, computing the mean of each sample, and then computing the average of the sample
    means.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The measurement errors cause the sample mean to be higher, on average, than
    3.7 kg.
  prefs: []
  type: TYPE_NORMAL
- en: Now here’s the same experiment using sample medians.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The average of the sample medians is also higher than 3.7 kg, but it is not
    off by nearly as much. If we compare the MSE of the estimates, we see that the
    sample medians are substantially more accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: If measurements actually come from a normal distribution, the sample mean minimizes
    MSE, but this scenario violates that assumption, so the sample mean doesn’t minimize
    MSE. The sample median is less sensitive to outliers, so it is less biased and
    its MSE is smaller. Estimators that deal well with outliers – and similar violations
    of assumptions – are said to be **robust**.
  prefs: []
  type: TYPE_NORMAL
- en: '## Estimating Variance'
  prefs: []
  type: TYPE_NORMAL
- en: As another example, suppose we want to estimate variance in the penguins’ weights.
    In [Chapter 1](chap01.html#section-summary-statistics), we saw that there are
    two ways to compute the variance of a sample. I promised to explain the difference
    later – and later is now.
  prefs: []
  type: TYPE_NORMAL
- en: The reason there are two ways to compute the variance of a sample is that one
    is a biased estimator of the population variance, and the other is unbiased. The
    following function computes the biased estimator, which is the sum of the squared
    deviations divided by `n`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: To test it, we’ll simulate many samples with size 10, compute the biased variance
    of each sample, and then compute the average of the variances.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The result is about 0.19, but in this case, we know that the actual population
    variance is about 0.21, so this version of the sample variance is too low on average
    – which confirms that it is biased.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The following function computes the unbiased estimator, which is the sum of
    the squared deviations divided by `n-1`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We can test it by generating many samples and computing the unbiased variance
    for each one.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The average of the unbiased sample variances is very close to the actual value
    – which is what we expect if it is unbiased.
  prefs: []
  type: TYPE_NORMAL
- en: With sample size 10, the difference between the biased and unbiased estimators
    is about 10%, which might be non-negligible. With sample size 100, the difference
    is only 1%, which is small enough that it probably doesn’t matter in practice.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]  ## Sampling Distributions'
  prefs: []
  type: TYPE_NORMAL
- en: So far we’ve been working with simulated data, assuming that penguin weights
    are drawn from a normal distribution with known parameters. Now let’s see what
    happens with real data.
  prefs: []
  type: TYPE_NORMAL
- en: Between 2007 and 2010, researchers at Palmer Station in Antarctica measured
    and weighed 342 penguins from local populations. The data they collected is freely
    available – instructions for downloading it are in the notebook for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The following cell downloads the data from a repository created by Allison Horst.
  prefs: []
  type: TYPE_NORMAL
- en: 'Horst AM, Hill AP, Gorman KB (2020). palmerpenguins: Palmer Archipelago (Antarctica)
    penguin data. R package version 0.1.0\. [https://allisonhorst.github.io/palmerpenguins/](https://allisonhorst.github.io/palmerpenguins/).
    doi: 10.5281/zenodo.3960218.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The data was collected as part of the research that led to this paper: Gorman
    KB, Williams TD, Fraser WR (2014). Ecological sexual dimorphism and environmental
    variability within a community of Antarctic penguins (genus Pygoscelis). PLoS
    ONE 9(3):e90081\. [https://doi.org/10.1371/journal.pone.0090081](https://doi.org/10.1371/journal.pone.0090081)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: We can use Pandas to read the data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The dataset includes three penguin species.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: For the first example we’ll select just the Chinstrap penguins.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: We’ll use this function to plot estimated PDFs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Here’s the distribution of chinstrap penguin weights in kilograms. The vertical
    dotted line shows the sample mean.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '![_images/4f97248ce47bd7b1f2bc9a596ca2c4c1cefd8edf9178f40cf803d042f0447c00.png](../Images/44f02b9e770b5556d8200f995f277676.png)'
  prefs: []
  type: TYPE_IMG
- en: The sample mean is about 3.7 kg.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: If you are asked to estimate the population mean, 3.7 kg is a reasonable choice
    – but how precise is that estimate?
  prefs: []
  type: TYPE_NORMAL
- en: One way to answer that question is to compute the **sampling distribution**
    of the mean, which shows how much the estimated mean varies from one sample to
    another. If we knew the actual mean and standard deviation in the population,
    we could model the sampling process and compute the sampling distribution. But
    if we knew the actual population mean, we wouldn’t have to estimate it!
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, there’s a simple way to approximate the sampling distribution,
    called **resampling**. The core idea is to use the sample to make a model of the
    population, then use the model to simulate the sampling process.
  prefs: []
  type: TYPE_NORMAL
- en: More specifically, we’ll use **parametric resampling**, which means we’ll use
    the sample to estimate the parameters of the population and then use a theoretical
    distribution to generate new samples.
  prefs: []
  type: TYPE_NORMAL
- en: The following function implements this process with a normal distribution. Notice
    that the new samples are the same size as the original.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This loop uses `resample` to generate many samples and compute the mean of each
    one.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The following figure shows the distribution of these sample means.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '![_images/8cb77fc51b75dd8db21d7b9ba3a14b0a6f0eff669632062dd368c72a249f3a6c.png](../Images/a06dfae260fb0dec044cdbc960094883.png)'
  prefs: []
  type: TYPE_IMG
- en: This result approximates the sampling distribution of the sample mean. It shows
    how much we expect the sample mean to vary if we collect many samples of the same
    size – assuming that our model of the population is accurate.
  prefs: []
  type: TYPE_NORMAL
- en: Informally, we can see that the sample mean could be as low as 3.55, if we collected
    another sample with the same size, or as high as 3.9.
  prefs: []
  type: TYPE_NORMAL
- en: Standard Error
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To quantify the width of the sampling distribution, one option is to compute
    its standard deviation – the result is called the **standard error**.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the standard error is about 0.045 kg – so if we collect many samples,
    we expect the sample means to vary by about 0.045 kg, on average.
  prefs: []
  type: TYPE_NORMAL
- en: 'People often confuse standard error and standard deviation. Remember:'
  prefs: []
  type: TYPE_NORMAL
- en: Standard deviation quantifies variation in measurements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standard error quantifies the precision of an estimate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this dataset, the standard deviation of penguin weights is about 0.38 kg
    for chinstrap penguins.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The standard error of the average weight is about 0.046 kg.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Standard deviation tells you how much penguins differ in weight. Standard error
    tells you how precise an estimate is. They are answers to different questions.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there is a relationship between them. If we know the standard deviation
    and sample size, we can approximate the standard error of the means like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: This result is close to what we got by resampling.
  prefs: []
  type: TYPE_NORMAL
- en: Confidence Intervals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another way to summarize the sampling distribution is to compute a **confidence
    interval**. For example, a 90% confidence interval contains 90% of the values
    in the sampling distribution, which we can find by computing the 5th and 95th
    percentiles. Here’s the 90% confidence interval for the average weight of chinstrap
    penguins.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: To interpret a confidence interval, it is tempting to say that there is a 90%
    chance that the true value of the population parameter falls in the 90% confidence
    interval. In this example, we would say there is a 90% chance that the population
    mean for chinstrap penguins is between 3.66 and 3.81 kg.
  prefs: []
  type: TYPE_NORMAL
- en: Under a strict philosophy of probability called **frequentism**, this interpretation
    would not be allowed, and in many statistics books, you will be told that this
    interpretation is wrong.
  prefs: []
  type: TYPE_NORMAL
- en: 'In my opinion, this prohibition is unnecessarily strict. Under reasonable philosophies
    of probability, a confidence interval means what people expect it to mean: there
    is a 90% chance that the true value falls in the 90% confidence interval.'
  prefs: []
  type: TYPE_NORMAL
- en: However, confidence intervals only quantify variability due to sampling – that
    is, measuring only part of the population. The sampling distribution does not
    account for other sources of error, notably sampling bias and measurement error,
    which are the topics of the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Sources of Error
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Suppose that instead of the average weight of penguins in Antarctica, you want
    to know the average weight of women in the city where you live. You can’t randomly
    choose a representative sample of women and weigh them.
  prefs: []
  type: TYPE_NORMAL
- en: A simple alternative would be “telephone sampling” – that is, you could choose
    random numbers from the phone book, call and ask to speak to an adult woman, and
    ask how much she weighs. But telephone sampling has obvious problems.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the sample is limited to people whose telephone numbers are listed,
    so it eliminates people without phones (who might be poorer than average) and
    people with unlisted numbers (who might be richer). Also, if you call home telephones
    during the day, you are less likely to sample people with jobs. And if you only
    sample the person who answers the phone, you are less likely to sample people
    who share a phone line.
  prefs: []
  type: TYPE_NORMAL
- en: If factors like income, employment, and household size are related to weight
    – and it is plausible that they are – the results of your survey would be affected
    one way or another. This problem is called **sampling bias** because it is a property
    of the sampling process.
  prefs: []
  type: TYPE_NORMAL
- en: This sampling process is also vulnerable to self-selection, which is a kind
    of sampling bias. Some people will refuse to answer the question, and if the tendency
    to refuse is related to weight, that would affect the results.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if you ask people how much they weigh, rather than weighing them, the
    results might not be accurate. Even helpful respondents might round up or down
    if they are uncomfortable with their actual weight. And not all respondents are
    helpful. These inaccuracies are examples of **measurement error**.
  prefs: []
  type: TYPE_NORMAL
- en: When you report an estimated quantity, it is useful to quantify variability
    due to sampling by reporting a standard error or a confidence interval. But remember
    that this variability is only one source of error, and often it is not the biggest.
  prefs: []
  type: TYPE_NORMAL
- en: Glossary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**population mean:** The true mean of a quantity in an entire population, as
    opposed to the sample mean, which is calculated from a subset.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**parameter**: One of the values that specify a particular distribution in
    a set of distributions – for example, the parameters of a normal distribution
    are the mean and standard deviation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**estimator**: A statistic calculated from a sample that is used to estimate
    a parameter of the population.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**consistent:** An estimator is consistent if it converges to the actual value
    of a parameter as the sample size increases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**unbiased:** An estimator is unbiased if, for a particular sample size, the
    average of the sample estimates is the actual value of the parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**mean squared error (MSE)**: A measure of the accuracy of an estimator – it’s
    the average squared difference between estimated and true parameter values, assuming
    the true value is known.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**robust:** An estimator is robust if it remains accurate even when a dataset
    contains outliers or errors – or does not perfectly follow a theoretical distribution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**resampling:** A way to approximate the sampling distribution of an estimate
    by simulating the sampling process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**parametric resampling:** A kind of resampling that estimates population parameters
    from sample data and then uses a theoretical distribution to simulate the sampling
    process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**sampling distribution**: The distribution of a statistic across possible
    samples from the same population.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**standard error**: The standard deviation of a sampling distribution, which
    quantifies the variability of an estimate due to random sampling (but not measurement
    error or non-representative sampling).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**confidence interval**: An interval that contains the most likely values in
    a sampling distribution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**sampling bias**: A flaw in the way a sample is collected that makes it unrepresentative
    of the population.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**measurement error**: Inaccuracy in how data are observed, measured, or recorded.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Exercise 8.1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the strengths of resampling methods is that they are easy to extend to
    other statistics. In this chapter, we computed the sample mean of penguin weights
    and then used resampling to approximate the sampling distribution of the mean.
    Now let’s do the same for standard deviation.
  prefs: []
  type: TYPE_NORMAL
- en: Compute the sample standard deviation of weights for chinstrap penguins. Then
    use `resample` to approximate the sampling distribution of the standard deviation.
    Use the sampling distribution to compute the standard error of the estimate and
    a 90% confidence interval.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 8.2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Behavioral Risk Factor Surveillance System (BRFSS) dataset includes self-reported
    heights and weights for a sample of adults in the United States. Use this data
    to estimate the average height of male adults. Use resample to approximate the
    sampling distribution and compute a 90% confidence interval.
  prefs: []
  type: TYPE_NORMAL
- en: Because the sample size is very large, the confidence interval is very small,
    which means that variability due to random sampling is small. But other sources
    of error might be bigger – what other sources of error do you think affect the
    results?
  prefs: []
  type: TYPE_NORMAL
- en: The following cells download the data, read it into a `DataFrame`, and select
    the heights of male respondents.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Exercise 8.3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In games like soccer and hockey, the time between goals tends to follow an exponential
    distribution (as we saw in [Chapter 6](chap06.html#section-exponential-pdf)).
    Suppose we observe a sample of times between goals. If we assume that the sample
    came from an exponential distribution, how can we estimate the actual mean of
    the distribution? We might consider using either the sample mean or the sample
    median. Let’s see if either of them is a consistent, unbiased estimator. For the
    experiments, we’ll assume that the actual mean time between goals is 10 minutes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: The following function generates a sample from an exponential distribution with
    this mean and the given sample size.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Use this function to generate samples with a range of sizes and compute the
    mean of each one. As `n` increases, do the sample means converge to the actual
    mean?
  prefs: []
  type: TYPE_NORMAL
- en: Next, generate samples with a range of sizes and compute the median of each
    one. Do the sample medians converge to the actual median?
  prefs: []
  type: TYPE_NORMAL
- en: Here’s the actual median of an exponential distribution with the given mean.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Next, generate many samples with size 10 and check whether the sample mean is
    an unbiased estimator of the population mean.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, check whether the sample median is an unbiased estimator of the population
    median.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 8.4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter we tested a biased estimator of variance and showed that it
    is, in fact, biased. And we showed that the unbiased estimator is unbiased. Now
    let’s try standard deviation.
  prefs: []
  type: TYPE_NORMAL
- en: 'To estimate the standard deviation of a population, we can compute the square
    root of the biased or unbiased estimator of variance, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Use `make_sample` to compute many samples of size 10 from a normal distribution
    with mean 3.7 and standard deviation 0.46. Check whether either of these is an
    unbiased estimator of standard deviation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Exercise 8.5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This exercise is based on the German tank problem, which is a simplified version
    of an actual analysis performed by the Economic Warfare Division of the American
    Embassy in London during World War II.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose you are an Allied spy and your job is to estimate how many tanks the
    Germans have built. As data, you have serial numbers recovered from `k` captured
    tanks.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we assume that the Germans have `N` tanks numbered from 1 to `N`, and that
    all tanks in this range were equally likely to be captured, we can estimate `N`
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: As an example, suppose `N` is 122.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: We can use the following function to generate a random sample of `k` tanks.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Here’s an example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: And here is the estimate based on this sample.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Check whether this estimator is biased.
  prefs: []
  type: TYPE_NORMAL
- en: For more on this problem, see [this Wikipedia page][[https://en.wikipedia.org/wiki/German_tank_problem](https://en.wikipedia.org/wiki/German_tank_problem)]
    and Ruggles and Brodie, “An Empirical Approach to Economic Intelligence in World
    War II”, Journal of the American Statistical Association, March 1947, available
    [here](https://web.archive.org/web/20170123132042/https://www.cia.gov/library/readingroom/docs/CIA-RDP79R01001A001300010013-3.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: For an explanation of how this estimator works, you might like [this video](https://www.youtube.com/watch?v=WLCwMRJBhuI).
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 8.6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In several sports – especially basketball – many players and fans believe in
    a phenomenon called the “hot hand”, which implies that a player who has hit several
    consecutive shots is more likely to hit the next, and a player who has missed
    several times is more likely to miss.
  prefs: []
  type: TYPE_NORMAL
- en: A famous paper proposed a way to test whether the hot hand is real or an illusion,
    by looking at sequences of hits and misses from professional basketball games.
    For each player, the authors computed the overall probability of making a shot,
    and the conditional probability of making a shot after three consecutive hits.
    For eight out of nine players, they found that the probability of making a shot
    was *lower* after three hits. Based on this and other results, they concluded
    that there is “no evidence for a positive correlation between the outcomes of
    successive shots”. And for several decades, many people believed that the hot
    hand had been debunked.
  prefs: []
  type: TYPE_NORMAL
- en: However, this conclusion is based on a statistical error, at least in part.
    A 2018 paper showed that the statistic used in the first paper – the probability
    of making a shot after three hits – is biased. Even if the probability of making
    every shot is exactly 0.5, and there is actually no correlation between the outcomes,
    the probability of making a shot after three hits is *less than 0.5*.
  prefs: []
  type: TYPE_NORMAL
- en: It is not obvious why that’s true, which is why the error went undetected for
    so long, and I won’t try to explain it here. But we can use the methods from this
    chapter to check it. We’ll use the following function to generate a sequence of
    0s and 1s with probability 0.5 and no correlation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: In the notebook for this chapter, I provide a function that finds all subsequences
    of three hits (1s) and returns the element of the sequence that follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Generate a large number of sequences with length 100 and for each sequence,
    find each shot that follows three hits. Compute the percentage of these shots
    that are hits. Hint: if the sequence does not contain three consecutive hits,
    the function returns an empty sequence, so your code will have to handle that.'
  prefs: []
  type: TYPE_NORMAL
- en: If you run this simulation many times, what is the average percentage of hits?
    How does this result vary as you increase or decrease the length of the sequence?
  prefs: []
  type: TYPE_NORMAL
- en: 'The famous paper is Gilovich, T., Vallone, R., & Tversky, A. (1985). The hot
    hand in basketball: On the misperception of random sequences. *Cognitive psychology*,
    17(3), 295-314.'
  prefs: []
  type: TYPE_NORMAL
- en: The paper showing the statistical error is Miller, J. B., & Sanjurjo, A. (2018).
    Surprised by the hot hand fallacy? A truth in the law of small numbers. *Econometrica*,
    86(6), 2019-2047.
  prefs: []
  type: TYPE_NORMAL
- en: The first paper is [available here](https://www.joelvelasco.net/teaching/122/Gilo.Vallone.Tversky.pdf).
    The second is [available here](https://marketing.wharton.upenn.edu/wp-content/uploads/2018/11/Paper-Joshua-Miller.pdf).
    For an overview of the topic and an explanation of the error, [you might like
    this video](https://www.youtube.com/watch?v=CR5vT44ZMK8).
  prefs: []
  type: TYPE_NORMAL
- en: '[Think Stats: Exploratory Data Analysis in Python, 3rd Edition](https://allendowney.github.io/ThinkStats/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Copyright 2024 [Allen B. Downey](https://allendowney.com)
  prefs: []
  type: TYPE_NORMAL
- en: 'Code license: [MIT License](https://mit-license.org/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Text license: [Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International](https://creativecommons.org/licenses/by-nc-sa/4.0/)'
  prefs: []
  type: TYPE_NORMAL
