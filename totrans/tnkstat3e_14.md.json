["```py\nfrom  os.path  import basename, exists\n\ndef  download(url):\n    filename = basename(url)\n    if not exists(filename):\n        from  urllib.request  import urlretrieve\n\n        local, _ = urlretrieve(url, filename)\n        print(\"Downloaded \" + local)\n\ndownload(\"https://github.com/AllenDowney/ThinkStats/raw/v3/nb/thinkstats.py\") \n```", "```py\ntry:\n    import  empiricaldist\nexcept ImportError:\n    %pip install empiricaldist \n```", "```py\nimport  numpy  as  np\nimport  pandas  as  pd\nimport  matplotlib.pyplot  as  plt\n\nfrom  thinkstats  import decorate\n\nplt.rcParams[\"figure.dpi\"] = 300 \n```", "```py\nfilename = \"Net_generation_for_all_sectors.csv\"\ndownload(\"https://github.com/AllenDowney/ThinkStats/raw/v3/data/\" + filename) \n```", "```py\nelec = (\n    pd.read_csv(\"Net_generation_for_all_sectors.csv\", skiprows=4)\n    .drop(columns=[\"units\", \"source key\"])\n    .set_index(\"description\")\n    .replace(\"--\", np.nan)\n    .transpose()\n    .astype(float)\n) \n```", "```py\nelec.columns \n```", "```py\nIndex(['Net generation for all sectors', 'United States',\n       'United States : all fuels (utility-scale)', 'United States : nuclear',\n       'United States : conventional hydroelectric',\n       'United States : other renewables', 'United States : wind',\n       'United States : all utility-scale solar', 'United States : geothermal',\n       'United States : biomass',\n       'United States : hydro-electric pumped storage',\n       'United States : all solar',\n       'United States : small-scale solar photovoltaic'],\n      dtype='object', name='description') \n```", "```py\nelec.index[:12] \n```", "```py\nIndex(['Jan 2001', 'Feb 2001', 'Mar 2001', 'Apr 2001', 'May 2001', 'Jun 2001',\n       'Jul 2001', 'Aug 2001', 'Sep 2001', 'Oct 2001', 'Nov 2001', 'Dec 2001'],\n      dtype='object') \n```", "```py\nelec.index = pd.date_range(start=\"2001-01\", periods=len(elec), freq=\"ME\")\nelec.index[:6] \n```", "```py\nDatetimeIndex(['2001-01-31', '2001-02-28', '2001-03-31', '2001-04-30',\n               '2001-05-31', '2001-06-30'],\n              dtype='datetime64[ns]', freq='ME') \n```", "```py\nactual_options = dict(color=\"C0\", lw=1, alpha=0.6)\ntrend_options = dict(color=\"C1\", alpha=0.6)\npred_options = dict(color=\"C2\", alpha=0.6, ls=':')\nmodel_options = dict(color=\"gray\", alpha=0.6, ls='--') \n```", "```py\nnuclear = elec[\"United States : nuclear\"]\nnuclear.plot(label=\"nuclear\", **actual_options)\n\ndecorate(ylabel=\"GWh\") \n```", "```py\ntrend = nuclear.rolling(window=12).mean() \n```", "```py\nnuclear.plot(label=\"nuclear\", **actual_options)\ntrend.plot(label=\"trend\", **trend_options)\ndecorate(ylabel=\"GWh\") \n```", "```py\ndetrended = (nuclear - trend).dropna()\ndetrended.plot(label=\"detrended\", **actual_options)\ndecorate(ylabel=\"GWh\") \n```", "```py\nmonthly_averages = detrended.groupby(detrended.index.month).mean()\nmonthly_averages.plot(label=\"monthly average\", **actual_options)\ndecorate(ylabel=\"GWh\") \n```", "```py\nseasonal = monthly_averages[nuclear.index.month]\nseasonal.index = nuclear.index\nseasonal.plot(label=\"seasonal\", **actual_options)\ndecorate(ylabel=\"GWh\") \n```", "```py\nexpected = trend + seasonal \n```", "```py\nexpected.plot(label=\"expected\", **pred_options)\nnuclear.plot(label=\"actual\", **actual_options)\ndecorate(ylabel=\"GWh\") \n```", "```py\nresid = nuclear - expected\nresid.plot(label=\"residual\", **actual_options)\ndecorate(ylabel=\"GWh\") \n```", "```py\nfrom  thinkstats  import plot_kde\n\nplot_kde(resid.dropna())\ndecorate(xlabel=\"Residual (GWh)\", ylabel=\"Density\") \n```", "```py\nrsquared = 1 - resid.var() / nuclear.var()\nrsquared \n```", "```py\nnp.float64(0.9054559977517084) \n```", "```py\nfrom  statsmodels.tsa.seasonal  import seasonal_decompose\n\ndecomposition = seasonal_decompose(nuclear, model=\"additive\", period=12) \n```", "```py\ndef  plot_decomposition(original, decomposition):\n    plt.figure(figsize=(6, 5))\n\n    ax1 = plt.subplot(4, 1, 1)\n    plt.plot(original, label=\"Original\", color=\"C0\", lw=1)\n    plt.ylabel(\"Original\")\n\n    plt.subplot(4, 1, 2, sharex=ax1)\n    plt.plot(decomposition.trend, label=\"Trend\", color=\"C1\", lw=1)\n    plt.ylabel(\"Trend\")\n\n    plt.subplot(4, 1, 3, sharex=ax1)\n    plt.plot(decomposition.seasonal, label=\"Seasonal\", color=\"C2\", lw=1)\n    plt.ylabel(\"Seasonal\")\n\n    plt.subplot(4, 1, 4, sharex=ax1)\n    plt.plot(decomposition.resid, label=\"Residual\", color=\"C3\", lw=1)\n    plt.ylabel(\"Residual\")\n\n    plt.tight_layout() \n```", "```py\nplot_decomposition(nuclear, decomposition) \n```", "```py\ndef  split_series(series, n=60):\n    training = series.iloc[:-n]\n    test = series.iloc[-n:]\n    return training, test \n```", "```py\ntraining, test = split_series(nuclear)\ntest.index[0] \n```", "```py\nTimestamp('2019-07-31 00:00:00') \n```", "```py\ndecomposition = seasonal_decompose(training, model=\"additive\", period=12)\ntrend = decomposition.trend \n```", "```py\nimport  statsmodels.formula.api  as  smf\n\nmonths = np.arange(len(trend))\ndata = pd.DataFrame({\"trend\": trend, \"months\": months}).dropna()\nresults = smf.ols(\"trend ~ months\", data=data).fit() \n```", "```py\nfrom  thinkstats  import display_summary\n\ndisplay_summary(results) \n```", "```py\nmonths = np.arange(len(training) + len(test))\ndf = pd.DataFrame({\"months\": months})\npred_trend = results.predict(df)\npred_trend.index = nuclear.index \n```", "```py\ntrend.plot(**trend_options)\npred_trend.plot(label=\"linear model\", **model_options)\ndecorate(ylabel=\"GWh\") \n```", "```py\nseasonal = decomposition.seasonal\nmonthly_averages = seasonal.groupby(seasonal.index.month).mean() \n```", "```py\npred_seasonal = monthly_averages[pred_trend.index.month]\npred_seasonal.index = pred_trend.index \n```", "```py\npred = pred_trend + pred_seasonal \n```", "```py\npred.plot(label=\"prediction\", **pred_options)\ntraining.plot(label=\"training\", **actual_options)\ndecorate(ylabel=\"GWh\") \n```", "```py\nforecast = pred[test.index]\nforecast.plot(label=\"predicted\", **pred_options)\ntest.plot(label=\"actual\", **actual_options)\ndecorate(ylabel=\"GWh\") \n```", "```py\ndef  MAPE(predicted, actual):\n    ape = np.abs(predicted - actual) / actual\n    return np.mean(ape) * 100 \n```", "```py\nMAPE(forecast, test) \n```", "```py\nnp.float64(3.811940747879257) \n```", "```py\nsolar = elec[\"United States : small-scale solar photovoltaic\"].dropna()\nsolar.plot(label=\"solar\", **actual_options)\ndecorate(ylabel=\"GWh\") \n```", "```py\ntraining, test = split_series(solar) \n```", "```py\ndecomposition = seasonal_decompose(training, model=\"multiplicative\", period=12) \n```", "```py\nplot_decomposition(training, decomposition) \n```", "```py\ntrend = decomposition.trend\nseasonal = decomposition.seasonal\nresid = decomposition.resid \n```", "```py\nrsquared = 1 - resid.var() / training.var()\nrsquared \n```", "```py\nnp.float64(0.9999999992978134) \n```", "```py\nmonths = range(len(training))\ndata = pd.DataFrame({\"trend\": trend, \"months\": months}).dropna()\nresults = smf.ols(\"trend ~ months + I(months**2)\", data=data).fit() \n```", "```py\ndisplay_summary(results) \n```", "```py\nmonths = range(len(solar))\ndf = pd.DataFrame({\"months\": months})\npred_trend = results.predict(df)\npred_trend.index = solar.index \n```", "```py\npred_trend.plot(label=\"quadratic model\", **model_options)\ntrend.plot(**trend_options)\ndecorate(ylabel=\"GWh\") \n```", "```py\nmonthly_averages = seasonal.groupby(seasonal.index.month).mean()\npred_seasonal = monthly_averages[pred_trend.index.month]\npred_seasonal.index = pred_trend.index \n```", "```py\npred = pred_trend * pred_seasonal \n```", "```py\ntraining.plot(label=\"training\", **actual_options)\npred.plot(label=\"prediction\", **pred_options)\ndecorate(ylabel=\"GWh\") \n```", "```py\nfuture = pred[test.index]\nfuture.plot(label=\"prediction\", **pred_options)\ntest.plot(label=\"actual\", **actual_options)\ndecorate(ylabel=\"GWh\") \n```", "```py\ndiff = (nuclear - nuclear.shift(12)).dropna()\ndiff.plot(label=\"year over year differences\", **actual_options)\ndecorate(ylabel=\"GWh\") \n```", "```py\ndf_ar = pd.DataFrame({\"diff\": diff})\nfor lag in [1, 2, 3]:\n    df_ar[f\"lag{lag}\"] = diff.shift(lag)\n\ndf_ar = df_ar.dropna() \n```", "```py\ndf_ar.corr()[[\"diff\"]] \n```", "```py\ndef  make_formula(df):\n  \"\"\"Make a Patsy formula from column names.\"\"\"\n    y = df.columns[0]\n    xs = \" + \".join(df.columns[1:])\n    return f\"{y} ~ {xs}\" \n```", "```py\nformula = make_formula(df_ar)\nresults_ar = smf.ols(formula=formula, data=df_ar).fit()\ndisplay_summary(results_ar) \n```", "```py\npred_ar = results_ar.predict(df_ar)\npred_ar.plot(label=\"predictions\", **pred_options)\ndiff.plot(label=\"differences\", **actual_options)\ndecorate(ylabel=\"GWh\") \n```", "```py\nresid_ar = (diff - pred_ar).dropna()\nR2 = 1 - resid_ar.var() / diff.var()\nR2 \n```", "```py\nnp.float64(0.3190252265690783) \n```", "```py\ndf_ma = pd.DataFrame({\"resid\": resid_ar})\n\nfor lag in [1, 6]:\n    df_ma[f\"lag{lag}\"] = resid_ar.shift(lag)\n\ndf_ma = df_ma.dropna() \n```", "```py\nformula = make_formula(df_ma)\nresults_ma = smf.ols(formula=formula, data=df_ma).fit()\ndisplay_summary(results_ma) \n```", "```py\npred_ma = results_ma.predict(df_ma) \n```", "```py\npred_diff = pred_ar + pred_ma \n```", "```py\nresid_ma = (diff - pred_diff).dropna()\nR2 = 1 - resid_ma.var() / diff.var()\nR2 \n```", "```py\nnp.float64(0.3315101001391231) \n```", "```py\npred_diff = pd.Series(pred_diff, index=nuclear.index) \n```", "```py\nn_missing = pred_diff.isna().sum()\nn_missing \n```", "```py\nnp.int64(21) \n```", "```py\npred_series = pd.Series(index=nuclear.index, dtype=float)\npred_series.iloc[:n_missing] = nuclear.iloc[:n_missing] \n```", "```py\nfor i in range(n_missing, len(pred_series)):\n    pred_series.iloc[i] = pred_series.iloc[i - 12] + pred_diff.iloc[i] \n```", "```py\npred_series[:n_missing] = np.nan \n```", "```py\npred_series.plot(label=\"predicted\", **pred_options)\nnuclear.plot(label=\"actual\", **actual_options)\ndecorate(ylabel=\"GWh\") \n```", "```py\nresid = (nuclear - pred_series).dropna()\nR2 = 1 - resid.var() / nuclear.var()\nR2 \n```", "```py\nnp.float64(0.8586566911201015) \n```", "```py\norder = ([1, 2, 3], 0, [1, 6]) \n```", "```py\nseasonal_order = (0, 1, 0, 12) \n```", "```py\nimport  statsmodels.tsa.api  as  tsa\n\nmodel = tsa.ARIMA(nuclear, order=order, seasonal_order=seasonal_order)\nresults_arima = model.fit()\ndisplay_summary(results_arima) \n```", "```py\nfittedvalues = results_arima.fittedvalues[n_missing:] \n```", "```py\nfittedvalues.plot(label=\"ARIMA model\", **pred_options)\nnuclear.plot(label=\"actual\", **actual_options)\ndecorate(ylabel=\"GWh\") \n```", "```py\nresid = fittedvalues - nuclear\nR2 = 1 - resid.var() / nuclear.var()\nR2 \n```", "```py\nnp.float64(0.8262717330822065) \n```", "```py\ntraining, test = split_series(nuclear)\nmodel = tsa.ARIMA(training, order=order, seasonal_order=seasonal_order)\nresults_training = model.fit() \n```", "```py\nforecast = results_training.get_forecast(steps=len(test)) \n```", "```py\nforecast_mean = forecast.predicted_mean\nforecast_ci = forecast.conf_int()\nforecast_ci.columns = [\"lower\", \"upper\"] \n```", "```py\nplt.fill_between(\n    forecast_ci.index,\n    forecast_ci.lower,\n    forecast_ci.upper,\n    lw=0,\n    color=\"gray\",\n    alpha=0.2,\n)\nplt.plot(forecast_mean.index, forecast_mean, label=\"forecast\", **pred_options)\nplt.plot(test.index, test, label=\"actual\", **actual_options)\ndecorate(ylabel=\"GWh\") \n```", "```py\nMAPE(forecast_mean, test) \n```", "```py\nnp.float64(3.3817549248044547) \n```", "```py\n# The following cell downloads data prepared by Our World in Data,\n# which I Downloaded September 18, 2024\n# from https://ourworldindata.org/grapher/average-monthly-surface-temperature\n\n# Based on modified data from Copernicus Climate Change Service information (2019)\n# with \"major processing\" by Our World in Data \n```", "```py\nfilename = \"monthly-average-surface-temperatures-by-year.csv\"\ndownload(\"https://github.com/AllenDowney/ThinkStats/raw/v3/data/\" + filename) \n```", "```py\ntemp = pd.read_csv(\"monthly-average-surface-temperatures-by-year.csv\") \n```", "```py\ntemp.head() \n```", "```py\ntemp_us = temp.query(\"Code == 'USA'\")\ncolumns = [str(year) for year in range(2000, 2025)]\ntemp_series = temp_us.loc[:, columns].transpose().stack()\ntemp_series.index = pd.date_range(start=\"2000-01\", periods=len(temp_series), freq=\"ME\") \n```", "```py\ntemp_series.plot(label=\"monthly average\", **actual_options)\ndecorate(ylabel=\"Surface temperature (degC)\") \n```", "```py\nutil_solar = elec[\"United States : all utility-scale solar\"].dropna()\nutil_solar = util_solar[util_solar.index.year >= 2014]\nutil_solar.plot(**actual_options)\ndecorate(ylabel=\"GWh\") \n```", "```py\nhydro = elec[\"United States : conventional hydroelectric\"]\nhydro.plot(**actual_options)\ndecorate(ylabel=\"GWh\") \n```"]